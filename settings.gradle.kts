/*
 * This file was generated by the Gradle 'init' task.
 *
 * The settings file is used to specify which projects to include in your build.
 * For more detailed information on multi-project builds, please refer to https://docs.gradle.org/9.2.0/userguide/multi_project_builds.html in the Gradle documentation.
 */

import java.io.File
import java.nio.file.Files
import java.nio.file.Path

plugins {
    // Apply the foojay-resolver plugin to allow automatic download of JDKs
    id("org.gradle.toolchains.foojay-resolver-convention") version "1.0.0"
}

rootProject.name = "buildlogic-gradle"

val rootPath = rootDir.toPath()
val excludedRoots = setOf(rootPath.resolve("buildSrc")).filter { Files.exists(it) }

fun Path.hasBuildScript(): Boolean =
    Files.isRegularFile(resolve("build.gradle.kts")) || Files.isRegularFile(resolve("build.gradle"))

fun Path.hasNoBuildMarker(): Boolean = Files.isRegularFile(resolve(".nobuild"))

fun Path.toGradleProjectPath(root: Path): String {
    val relative = root.relativize(this).toString().replace(File.separatorChar, ':')
    return ":$relative"
}

/**
 * Returns true when this path is located within a directory segment named "build" or ".gradle"
 * relative to the provided [root]. Used to skip generated output directories that may by
 * coincidence contain files named like build scripts.
 */
fun Path.isInIgnoredSubdirectory(root: Path): Boolean {
    val rel = root.relativize(this)
    for (i in 0 until rel.nameCount) {
        val seg = rel.getName(i).toString()
        if (seg == "build" || seg == ".gradle") return true
    }
    return false
}

Files.walk(rootPath).use { paths ->
    paths
        .filter { Files.isDirectory(it) }
        .filter { it != rootPath } 
        .filter { candidate -> excludedRoots.none { candidate.startsWith(it) } }
        // Ignore any directory that is inside a `build` or `.gradle` subtree when that
        // directory also contains a build script (these are commonly generated directories).
        .filter { candidate -> !(candidate.isInIgnoredSubdirectory(rootPath) && candidate.hasBuildScript()) }
        .filter { candidate -> candidate.hasBuildScript() && !candidate.hasNoBuildMarker() }
        .map { it.toGradleProjectPath(rootPath) }
        .sorted()
        .forEach { include(it) }
}

